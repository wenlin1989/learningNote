## 多线程并发编程常会使用锁机制
### 1. 悲观锁：Pessimistic Lock
* 每次一个事务读取某一条记录后，就会把这条记录锁住，这样其它的事务要想更新，必须等以前的事务提交或者回滚解除锁
* 传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁
* 大多在数据库层面实现加锁操作，比如JDBC方式：在JDBC中使用悲观锁，需要使用
> select for update语句  Select * from Account where ...(where condition).. for update
* **认为系统中的并发更新会非常频繁**
###2. 乐观锁：Optimistic Lock
* 每次提交一个事务更新时，我们想看看要修改的东西从上次读取以后有没有被其它事务修改过，如果修改过，那么更新就会失败
* 乐观锁适用于多读的应用类型，这样可以提高吞吐量，像数据库如果提供类似于write_condition机制的其实都是提供的乐观锁
* 大多是基于数据版本（Version）记录机制实现,即为数据增加一个版本标识，在基于数据库表的版本解决方案中，一般是通过为数据库表增加一个 “version” 字段来实现
* 读取出数据时，将此版本号一同读出，之后更新时，对此版本号加一。此时，将提交数据的版本数据与数据库表对应记录的当前版本信息进行比对，如果提交的数据 版本号大于数据库表当前版本号，则予以更新，否则认为是过期数据。
* Java代码中使用Synchronized进行跨线程的同步的方式就属于悲观锁，它有一个明显的缺点，它不管数据之间存不存在竞争都会加锁，随着并发量的增加，且如果锁的时间比较长，其性能开销将会变得很大
* 认为系统中的事务并发更新不会很频繁
###3. 基于冲突检测的乐观锁：
* 每条线程都直接先去执行操作，计算完成后检测是否与其他线程存在共享数据竞争，如果没有则让此操作成功，如果存在共享数据竞争则可能不断地重新执行操作和检测，直到成功为止，这种叫做CAS（CompareAndSet）自旋
